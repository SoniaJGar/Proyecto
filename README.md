#  Funciones  utilizadas en el proyecto de investigacción de detección de hipoxia fetal con redes neuronales.
La hipoxia fetal es una condición médica grave en la que el feto no recibe suficiente oxígeno durante el embarazo, lo que puede provocar daños cerebrales y otros problemas de salud. La detección temprana de la hipoxia fetal es fundamental para tomar medidas para proteger la salud del feto.
En los últimos años, el uso de técnicas de aprendizaje profundo, específicamente redes neuronales profundas, se ha convertido en un enfoque prometedor para la detección de hipoxia fetal a partir de señales fisiológicas. Las redes neuronales profundas han demostrado su eficacia en la identificación de patrones complejos en señales biomédicas, lo que las hace ideales para la detección de hipoxia fetal a partir de señales de frecuencia cardíaca fetal y contracciones uterinas.
En este contexto, el objetivo de este repositorio es proporcionar un conjunto de funciones útiles que han sido utilizadas en el desarrollo de un proyecto de investigación sobre la detección de hipoxia fetal mediante redes neuronales profundas.  Dichas funciones se pueden encontrar  en el archivo  **codigo.py**.
Espero que este repositorio sea de ayuda para la comunidad científica  y pueda contribuir al avance en dicho problema,  así como puedan ser de gran utilidad para otros investigadores y profesionales del campo de la medicina y la ingeniería biomédica  para el procesamiento y análisis de señales.

### Descripción de las funciones.
> **Preprocesado de señales**. <br>
>  El preprocesamiento de señales es una tarea fundamental en la detección de hipoxia fetal mediante redes neuronales profundas. El objetivo de esta etapa es preparar las señales de entrada para que puedan ser utilizadas por los modelos de aprendizaje profundo, eliminando ruido y artefactos y resaltando las características relevantes de la señal. Estas funciones son aplicadas a las señales  de CTG,  contenidas en archivos .dat.  Cabe destacar que las funciones han sido creadas con la idea de ejecutarlas  en el orden que se muestras. <br>
>  - clean_infal(): función  que elimina los valores nulos de los extremos de las señales de FHR y UC.  Sin embargo, solo suprime  aquellos en los que se cumpla que tanto la posición en la señal de FHR como en la de UC poseen valor nulo.  Solo toma de entrada  el número  de identificación de la señal, el cual esta contenido en el nombre del archivo.  Como salida se obtiene un array que contiene los valores de las señales procesadas. <br>
>  - gap_clean(): función que elimina fragmentos de valores nulos en el interior de la señal de un  cierto tamaño. Al igual que antes, el  fragmento debe ser  de valores nulos en  las mismas posiciones de ambas señales. Toma como  entrada la señal y el tamaño del fragmento . Como salida se obtiene  un array que contiene los valores de las señales ya procesadas. <br>
>  - zeros_to_nan(): esta función  tiene como entrada la señal y además ciertos umbrales  a partir de los cuales  los valores de las señales son considerados como ruido.  Siguiendo esto, la función convierte los valos nulos restantes de las señales en  valores no numéricos (NaN), así como  todos aquellos que superen o sean inferiores a los umbrales establecidos para cada señal. Finalmente, se obtiene como resultado un a rray con los valores de las señales limpias. <br>

>**Etiquetado**. <br>
>  Dado que el problema abordado  es de clasificación binaria, es necesario contar con etiquetas que permitan clasificar cada señal como normal o hipóxica. Por este motivo se desarolla una función que devuelva  la etiqueta de cada una de las señales en función del ph del cordón umbilical, dato que puede encontrarsese en los archivos .hea de cada señal. 
> - target(): función que toma de entrada  el valor del ph umbilical y  un umbral, a partir del cual se establecerán  ambas clases. De esta manera, las señales cuyo valor de ph asociado sea inferior  al umbral establecido serán clasificadas como hipóxicas y etiquetadas como consecuencia con un 1. Por el contrario, si el ph asociado es superior al umbral serán clasificadas como normales y etiquetadas con un 0. Como salida se obtiene un array con las etiquetas de las señales y el número de señales normles y señales hipóxicas.

>**Arquitecturas de los modelos**.<br>
> Se presentan en este apartado las funciones  que permiten la construcción y entrenamiento de modelos basados en dos arquitecturas populares: redes convolucionales y redes LSTM.
>  - build_cnn_model():  función utilizada para construir una red  neuronal convolucional. Recibe como argumentos la cantidad de unidades (neuronas) en la capa convolucional, el tamaño del kernel (ventana de filtrado) y el valor de regularización para el kernel. En la función, primero se crea una instancia del modelo Sequential de Keras, que se utiliza para apilar capas de forma secuencial. Luego, se agrega una capa convolucional con activación ReLU y regularización L2, seguida de una capa de maxpooling para reducir la dimensionalidad de la salida de la capa convolucional.  Después, se agrega una capa de flatten para aplanar la salida y pasarla a una capa totalmente conectada con una sola neurona y activación sigmoide, lo que convierte la salida en una probabilidad entre 0 y 1. Finalmente, el modelo se compila con la  función de  pérdida de entro  
>   
>  
>     
